<?xml version="1.0" encoding="utf-8" ?>

<chapter id="test-doubles">
  <title>Doublure de test</title>

  <para>
    Gerard Meszaros introduit le concept de doublure de test dans
    <xref linkend="Meszaros2007" /> comme ceci:
  </para>

  <blockquote>
    <attribution>Gerard Meszaros</attribution>
    <para>
      <indexterm><primary>Système à tester</primary></indexterm>

      Parfois il est parfaitement difficile de juste tester un système en cours de test (SCT)
      parce qu'il dépend d'autres composants qui ne peuvent pas être utilisés dans l'environnement de test.
      Ceci peut provenir du fait qu'ils ne sont pas disponibles, qu'ils ne retournent pas les résultats
      nécessaires pour les tests ou parce que les exécuter pourrait avoir des effets de bord indésirables.
      Dans d'autres cas, notre stratégie de test nécessite que nous ayons plus de contrôle ou de visibilité
      sur le comportement interne du SCT.
    </para>

    <para>
      <indexterm><primary>Composant dépendant</primary></indexterm>
      <indexterm><primary>Doublure de test</primary></indexterm>

      Quand nous écrivons un test dans lequel nous ne pouvons pas (ou ne voulons pas)
      utiliser un composant réel dont on dépend (depended-on component ou DOC), nous
      pouvons le remplacer avec une doublure de test. La doublure de test ne se comporte pas exactement
      comme un vrai DOC; elle a simplement à fournir la même API que le composant réel de telle
      sorte que le système testé pense qu'il s'agit du vrai !
    </para>
  </blockquote>

  <para>
    Les méthodes <literal>getMock($nomClasse)</literal> et
    <literal>getMockBuilder($type)</literal> fourni par PHPUnit peuvent être
    utilisées dans un test pour générer automatiquement un objet qui peut agir comme une
    doublure de test pour une classe originelle indiquée (interface ou non de classe).
    Cette doublure de test peut être utilisée dans tous les contextes où la classe
    originelle est attendue ou requise.
  </para>

  <para>
    La méthode <literal>createMock($type)</literal> retourne immédiatement une doublure de
    test pour le type spécifié (interface ou classe). La création de cette doublure est
    effectuée en suivant par défaut les bonne pratiques (les méthodes <literal>__construct()
    </literal> et <literal>__clone()</literal> de la classe originale ne sont pas executées
    et les arguments passés à une méthode de la doublure de tests ne sont pas clonés. Si ce
    comportement par défaut ne correspondent pas à ce don vous avez besoin vous pouvez
    alors utiliser la méthode <literal>getMockBuilder($type)</literal> pour personnaliser la
    génération de doublure de test en utilisant un interface souple (fluent interface).
  </para>

  <para>
    Par défaut, toutes les méthodes de la classe originelle sont remplacées par une
    implémentation fictive qui se contente de retourner <literal>NULL</literal> (sans
    appeler la méthode originelle). En utilisant la méthode <literal>will($this->returnValue())</literal>
    par exemple, vous pouvez configurer ces implémentations fictives pour
    retourner une valeur donnée quand elles sont appelées.
  </para>

  <note>
    <title>Limitations: méthodes final, private et static</title>

    <para>
      Merci de noter que les méthodes <literal>final</literal>, <literal>private</literal>
      et <literal>static</literal> ne peuvent pas être remplacées par un bouchon (stub) ou un simulacre (mock).
      Elles seront ignorées par la fonction de doublure de test de PHPUnit et conserveront
      leur comportement initial.
    </para>
  </note>

  <section id="test-doubles.stubs">
    <title>Bouchons</title>

    <para>
      <indexterm><primary>Bouchon</primary></indexterm>

      La pratique consistant à remplacer un objet par une doublure de test qui
      retourne (de façon facultative) des valeurs de retour configurées est
      appelée <emphasis>bouchonnage</emphasis>. Vous pouvez utiliser un <emphasis>bouchon</emphasis> pour
      "remplacer un composant réel dont dépend le système testé de telle façon que
      le test possède un point de contrôle sur les entrées indirectes dans le SCT. Ceci
      permet au test de forcer le SCT à utiliser des chemins qu'il n'aurait pas
      emprunté autrement".
    </para>

    <para>
      <indexterm><primary>Interface souple</primary></indexterm>

      <xref linkend="test-doubles.stubs.examples.StubTest.php" /> montre comment
      la méthode de bouchonnage appelle et configure des valeurs de retour. Nous utilisons
      d'abord la méthode <literal>createMock()</literal> qui est fournie par la classe
      <literal>PHPUnit\Framework\TestCase</literal> pour configurer un objet bouchon
      qui ressemble à un objet de <literal>SomeClass</literal>
      (<xref linkend="test-doubles.stubs.examples.SomeClass.php" />). Ensuite nous
      utilisons <ulink url="http://martinfowler.com/bliki/FluentInterface.html">l'interface souple</ulink>
      que PHPUnit fournit pour indiquer le comportement de ce bouchon. En substance,
      cela signifie que vous n'avez pas besoin de créer plusieurs objets temporaires
      et les relier ensemble ensuite. Au lieu de cela, vous chaînez les appels de méthode
      comme montré dans l'exemple. Ceci amène à un code plus lisible et "souple".
    </para>

    <example id="test-doubles.stubs.examples.SomeClass.php">
      <title>La classe que nous voulons bouchonner</title>
      <programlisting><![CDATA[<?php
class SomeClass
{
    public function doSomething()
    {
        // Faire quelque chose.
    }
}
?>]]></programlisting>
    </example>

    <example id="test-doubles.stubs.examples.StubTest.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>willReturn()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour retourner une valeur fixée</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testBouchon()
    {
        // Créer un bouchon pour la classe UneClasse.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->willReturn('foo');

        // Appeler $stub->doSomething() va maintenant retourner
        // 'foo'.
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <note>
      <title>Limitation: Méthodes nommées "method"</title>

      <para>
        L'exemple ci dessus ne fonctionne que si la classe originale ne déclare
        pas de méthode appelé "method".
      </para>

      <para>
        Si la classe originale déclare une methode appelée "methode" alors vous devez utiliser
        <literal><![CDATA[$stub->expects($this->any())->method('doSomething')->willReturn('foo');]]></literal>.
      </para>
    </note>

    <para>
      "Dans les coulisses", PHPUnit génère automatiquement une nouvelle classe qui
      implémente le comportement souhaité quand la méthode <literal>createMock()</literal>
      est utilisée.
    </para>

    <para>
      <xref linkend="test-doubles.stubs.examples.StubTest2.php"/> montre un exemple
      de comment utiliser l'interface souple du créateur de mock pour configurer
      la création d'une doublure de test. La configuration de cette doublure de test
      utilise les même bonnes pratiques utilisées par défaut par <literal>createMock()</literal>.
    </para>

    <example id="test-doubles.stubs.examples.StubTest2.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>willReturn()</primary></indexterm>
      <title>L'API de construction des mock peut-être utilisée pour configurer la doublure de test générée.</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->getMockBuilder($originalClassName)
                     ->disableOriginalConstructor()
                     ->disableOriginalClone()
                     ->disableArgumentCloning()
                     ->disallowMockingUnknownTypes()
                     ->getMock();

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->willReturn('foo');

        // Appeler $stub->doSomething() retournera désormais
        // 'foo'.
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      Dans les exemples précédents, nous avons retourné des valeurs simple en utilisant
      <literal>willReturn($value)</literal>. Cette syntaxe courte est identique à
      <literal>will($this->returnValue($value))</literal>. Nous pouvons utiliser des variantes
      de cette syntaxte plus longue pour obtenir un comportement de bouchonnement plus complexe.
    </para>

    <para>
      Parfois vous voulez renvoyer l'un des paramètres d'un appel de méthode
      (non modifié) comme résultat d'un appel méthode bouchon.
      <xref linkend="test-doubles.stubs.examples.StubTest3.php"/> montre comment vous
      pouvez obtenir ceci en utilisant <literal>returnArgument()</literal> à la place de
      <literal>returnValue()</literal>.
    </para>

    <example id="test-doubles.stubs.examples.StubTest3.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnArgument()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour renvoyer un des paramètres</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testReturnArgumentStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->returnArgument(0));

        // $stub->doSomething('foo') retourn 'foo'
        $this->assertEquals('foo', $stub->doSomething('foo'));

        // $stub->doSomething('bar') returns 'bar'
        $this->assertEquals('bar', $stub->doSomething('bar'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Quand on teste interface souple, il est parfois utile que la méthode bouchon
      retourne une référence à l'objet bouchon.
      <xref linkend="test-doubles.stubs.examples.StubTest4.php"/> présente comment
      utiliser <literal>returnSelf()</literal> pour accomplir cela.
    </para>

    <example id="test-doubles.stubs.examples.StubTest4.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnSelf()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour renvoyer une référence de l'objet bouchon.</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testReturnSelf()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->returnSelf());

        // $stub->doSomething() retourne $stub
        $this->assertSame($stub, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      Parfois, une méthode bouchon doit retourner différentes valeurs selon
      une liste prédéfinie d'arguments. Vous pouvez utiliser
      <literal>returnValueMap()</literal> pour créer une association entre les
      paramètres et les valeurs de retour correspondantes. Voir
      <xref linkend="test-doubles.stubs.examples.StubTest5.php"/> pour
      un exemple.
    </para>

    <example id="test-doubles.stubs.examples.StubTest5.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValueMap()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour retourner la valeur à partir d'une association</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testReturnValueMapStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Créer une association entre arguments et valeurs de retour
        $map = [
            ['a', 'b', 'c', 'd'],
            ['e', 'f', 'g', 'h']
        ];

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->returnValueMap($map));

        // $stub->doSomething() retourne différentes valeurs selon
        // les paramètres fournis.
        $this->assertEquals('d', $stub->doSomething('a', 'b', 'c'));
        $this->assertEquals('h', $stub->doSomething('e', 'f', 'g'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Quand l'appel d'une méthode bouchonné doit retourner une valeur calculée au lieu
      d'une valeur fixée (voir <literal>returnValue()</literal>) ou un paramètre
      (non modifié) (voir <literal>returnArgument()</literal>), vous pouvez utiliser
      <literal>returnCallback()</literal> pour que la méthode retourne le résultat
      d'une fonction ou méthode de rappel. Voir
      <xref linkend="test-doubles.stubs.examples.StubTest6.php"/> pour un exemple.
    </para>

    <example id="test-doubles.stubs.examples.StubTest6.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnCallback()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour retourner une valeur à partir d'une fonction de rappel</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testReturnCallbackStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->returnCallback('str_rot13'));

        // $stub->doSomething($argument) retourne str_rot13($argument)
        $this->assertEquals('fbzrguvat', $stub->doSomething('something'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Une alternative plus simple pour configurer une méthode de rappel peut
      consister à indiquer une liste de valeurs désirées. Vous pouvez faire
      ceci avec la méthode <literal>onConsecutiveCalls()</literal>. Voir
      <xref linkend="test-doubles.stubs.examples.StubTest7.php"/> pour
      un exemple.
    </para>

    <example id="test-doubles.stubs.examples.StubTest7.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>onConsecutiveCalls()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour retourner une liste de valeurs dans
      l'ordre indiqué</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testOnConsecutiveCallsStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->onConsecutiveCalls(2, 3, 5, 7));

        // $stub->doSomething() retourne une valeur différente à chaque fois
        $this->assertEquals(2, $stub->doSomething());
        $this->assertEquals(3, $stub->doSomething());
        $this->assertEquals(5, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>


    <para>
      Au lieu de retourner une valeur, une méthode bouchon peut également lever
      une exception. <xref linkend="test-doubles.stubs.examples.StubTest8.php"/>
      montre comme utiliser <literal>throwException()</literal> pour faire cela.
    </para>

    <example id="test-doubles.stubs.examples.StubTest8.php">
      <indexterm><primary>createMock()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>throwException()</primary></indexterm>
      <title>Bouchonner un appel de méthode pour lever une exception</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class StubTest extends TestCase
{
    public function testThrowExceptionStub()
    {
        // Créer un bouchon pour la classe SomeClass.
        $stub = $this->createMock(SomeClass::class);

        // Configurer le bouchon.
        $stub->method('doSomething')
             ->will($this->throwException(new Exception));

        // $stub->doSomething() throws Exception
        $stub->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      Alternativement, vous pouvez écrire le bouchon vous-même et améliorer votre conception
      ce-faisant. Des ressources largement utilisées sont accédées via une unique façade,
      de telle sorte que vous pouvez facilement remplacer la ressource avec le bouchon. Par exemple,
      au lieu d'avoir des appels directs à la base de données éparpillés dans tout le code,
      vous avez un unique objet <literal>Database</literal>, une implémentation de
      l'interface <literal>IDatabase</literal>. Ensuite, vous pouvez créer
      une implémentation bouchon de <literal>IDatabase</literal> et l'utiliser pour
      vos tests. Vous pouvez même créer une option pour lancer les tests dans la
      base de données bouchon ou la base de données réelle, de telle sorte que vous
      pouvez utiliser vos tests à la fois pour tester localement pendant le développement
      et en intégration avec la vraie base de données.
    </para>

    <para>
      Les fonctionnalités qui nécessitent d'être bouchonnées tendent à se regrouper
      dans le même objet, améliorant la cohésion. En représentant la fonctionnalité
      avec une unique interface cohérente, vous réduisez le couplage avec le reste
      du système.
    </para>
  </section>

  <section id="test-doubles.mock-objects">
    <title>Objets simulacres (Mock Objects)</title>

    <para>
      La pratique consistant à remplacer un objet avec une doublure de test
      qui vérifie des attentes, par exemple en faisant l'assertion qu'une méthode
      a été appelée, est appelée <emphasis>simulacre</emphasis>.
    </para>

    <para>
      <indexterm><primary>Objet simulacre</primary></indexterm>

      Vous pouvez utiliser un <emphasis>objet simulacre</emphasis> "comme un point d'observation
      qui est utilisé pour vérifier les sorties indirectes du système quand il est testé. Typiquement,
      le simulacre inclut également la fonctionnalité d'un bouchon de test, en ce sens qu'il doit
      retourner les valeurs du système testé s'il n'a pas déjà fait échouer les tests mais l'accent
      est mis sur la vérification des sorties indirectes. Ainsi, un simulacre est un beaucoup plus
      qu'un simple bouchon avec des assertions; il est utilisé d'une manière
      fondamentalement différente" (Gerard Meszaros).
    </para>

    <note>
      <title>Limitation: Vérification automatique des attentes</title>

      <para>
        Seuls les objets simulacres générés dans le scope d'un test seront vérifiés
        automatiquement par PHPUnit. Les mocks générés dans les fournisseurs de données,
        par exemple, ou injectés dans les tests en utilisant l'annotation <literal>@depends</literal>
        ne seront pas vérifiés automatiquement par PHPUnit.
      </para>
    </note>

    <para>
      Voici un exemple: supposons que vous voulez tester que la méthode correcte,
      <literal>update()</literal> dans notre exemple, est appelée d'un objet qui observe un autre objet.
      <xref linkend="test-doubles.mock-objects.examples.SUT.php"/>
      illustre le code pour les classes <literal>Subject</literal> et <literal>Observer</literal>
      qui sont une partie du système testé (SUT).
    </para>

    <example id="test-doubles.mock-objects.examples.SUT.php">
      <title>Les classes Subject et Observer qui sont une partie du système testé</title>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class Subject
{
    protected $observers = [];
    protected $name;

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function getName()
    {
        return $this->name;
    }

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function doSomething()
    {
        // Faire quelque chose.
        // ...

        // Notify les observateurs que nous faisons quelque chose
        $this->notify('something');
    }

    public function doSomethingBad()
    {
        foreach ($this->observers as $observer) {
            $observer->reportError(42, 'Something bad happened', $this);
        }
    }

    protected function notify($argument)
    {
        foreach ($this->observers as $observer) {
            $observer->update($argument);
        }
    }

    // Autres méthodes.
}

class Observer
{
    public function update($argument)
    {
        // Faire quelquechose
    }

    public function reportError($errorCode, $errorMessage, Subject $subject)
    {
        // Faire quelquechose
    }

    // Autre méthodes
}
?>]]></programlisting>
    </example>

    <para>
      <indexterm><primary>Objet simulacre</primary></indexterm>

      <xref linkend="test-doubles.mock-objects.examples.SubjectTest.php" />
      illustre comment utiliser un simulacre pour tester l'interaction entre
      les objets <literal>Sujet</literal> et <literal>Observateur</literal>.
    </para>

    <para>
      Nous utilisons d'abord la méthode <literal>getMock()</literal> qui est fournie par
      la classe <literal>PHPUnit_Framework_TestCase</literal> pour configurer un simulacre
      pour l'<literal>Observateur</literal>. Puisque nous donnons un tableau comme second
      paramètre (facultatif) pour la méthode <literal>getMock()</literal>,
      seule la méthode <literal>update()</literal> de la classe <literal>Observateur</literal> est
      remplacée par une implémentation d'un simulacre.
    </para>

    <example id="test-doubles.mock-objects.examples.SubjectTest.php">
      <title>Tester qu'une méthode est appelée une fois et avec un paramètre indiqué</title>
      <programlisting><![CDATA[<?php

require_once 'Sujet.php';

class SujetTest extends PHPUnit_Framework_TestCase
{
    public function testLesObservateursSontMisAJour()
    {
        // Créer un simulacre pour la classe Observateur,
        // ne touchant que la méthode update().
        $observateur = $this->getMock('Observateur', array('update'));

        // Configurer l'attente de la méthode update()
        // d'être appelée une seule fois et avec la chaîne 'quelquechose'
        // comme paramètre.
        $observateur->expects($this->once())
                 ->method('update')
                 ->with($this->equalTo('quelque chose'));

        // Créer un objet Sujet et y attacher l'objet Observateur
        // simulé
        $sujet = new Sujet;
        $sujet->attache($observateur);

        // Appeler la méthode faireQuelquechose() sur l'objet $sujet
        // que nous attendons voir appeler la méthode update() de l'objet
        // simulé Observateur avec la chaîne 'quelqueChose'.
        $sujet->faireQuelquechose();
    }
}
?>]]></programlisting>
    </example>

    <para>
      La méthode <literal>with()</literal> peut prendre n'importe quel
      nombre de paramètres, correspondant au nombre de paramètres des méthodes
      étant simulées. Vous pouvez indiquer des contraintes plus avancées
      sur les paramètres de méthode qu'une simple correspondance.
    </para>

    <example id="test-doubles.mock-objects.examples.MultiParameterTest.php">
      <title>Tester qu'une méthode est appelée avec un nombre de paramètres contraints de différentes manières</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testRapportErreur()
    {
        // Créer un simulacre pour la classe Observateur, en simulant
        // la méthode rapportErreur()
        $observateur = $this->getMock('Observateur', array('rapportErreur'));

        $observateur->expects($this->once())
                 ->method('rapportErreur')
                 ->with($this->greaterThan(0),
                        $this->stringContains('Quelquechose'),
                        $this->anything());

        $sujet = new Subject;
        $sujet->attach($observateur);

        // La méthode faireQuelquechoseDeMal doit rapporter une erreur à l'observateur
        // via la méthode rapportErreur()
        $sujet->faireQuelquechoseDeMal();
    }
}
?>]]></programlisting>
    </example>

    <para>
      <xref linkend="writing-tests-for-phpunit.assertions.assertThat.tables.constraints"/>
      montre les contraintes qui peuvent être appliquées aux paramètres de méthode et
      <xref linkend="test-doubles.mock-objects.tables.matchers"/>
      montre les matchers qui sont disponibles pour indiquer le nombre d'
      invocations.
    </para>

    <table id="test-doubles.mock-objects.tables.matchers">
      <title>Matchers</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead>
          <row>
            <entry>Matcher</entry>
            <entry>Signification</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_AnyInvokedCount any()</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué est exécutée zéro ou davantage de fois.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount never()</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué n'est jamais exécutée.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtLeastOnce atLeastOnce()</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué est exécutée au moins une fois.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount once()</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué est exécutée exactement une fois.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount exactly(int $nombre)</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué est exécutée exactement <literal>$nombre</literal> fois.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtIndex at(int $index)</literal></entry>
            <entry>Retourne un matcher qui correspond quand la méthode pour laquelle il est évalué est invoquée pour l'<literal>$index</literal> spécifié.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      <indexterm><primary>getMockForAbstractClass()</primary></indexterm>

      La méthode <literal>getMockForAbstractClass()</literal> retourne un simulacre
      pour une classe abstraite. Toutes les méthodes abstraites d'une classe simulacre
      donnée sont simulées. Ceci permet de tester les méthodes concrètes d'une classe
      abstraite.
    </para>

    <example id="test-doubles.mock-objects.examples.AbstractClassTest.php">
      <title>Tester les méthodes concrêtes d'une classe abstraite</title>
      <programlisting><![CDATA[<?php
abstract class ClasseAbstraite
{
    public function methodeConcrete()
    {
        return $this->methodeAbstraite();
    }

    public abstract function methodeAbstraite();
}

class ClasseAbstraiteTest extends PHPUnit_Framework_TestCase
{
    public function testConcreteMethod()
    {
        $stub = $this->getMockForAbstractClass('ClasseAbstraite');
        $stub->expects($this->any())
             ->method('methodeAbstraite')
             ->will($this->returnValue(TRUE));

        $this->assertTrue($stub->methodeConcrete());
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.prophecy">
    <title>Prophecy</title>

    <para>
      <ulink url="https://github.com/phpspec/prophecy">Prophecy</ulink> est un
      "framework de librairie de mock pour object PHP fortement arrêtée dans
      ses options mais tout du moins très puissant et flexible. Créé en premier
      lieu pour satisfaire les besoins de phpspec2, il est assez flexible pour
      être utilisé dans n'importe quel framework de test, avec très peu
      d'efforts".
    </para>

    <para>
      PHPUnit supporte nativement l'utilisation de Prophecy pour créer des
      doublures depuis la version 4.5. <xref linkend="test-doubles.prophecy.examples.SubjectTest.php"/>
      montre comment le même test peut écrit dans <xref linkend="test-doubles.mock-objects.examples.SubjectTest.php"/>
      en utilisant la philosophy des prophéties et des révélations:
    </para>

    <example id="test-doubles.prophecy.examples.SubjectTest.php">
      <title>Tester qu'une méthode est appelée une fois avec un argument spécifique</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testObserversAreUpdated()
    {
        $subject = new Subject('My subject');

        // Créer une prohétie pour une classe Observer.
        $observer = $this->prophesize('Observer');

        // Configurer le comportement attendu pour la méthode update()
        // afin qu'elle soit appellée qu'une fois, avec la string 'something'
        // comme paramètre.
        $observer->update('something')->shouldBeCalled();

        // Révéler la prophetie et attacher le mock à l'object Subject.
        $subject->attach($observer->reveal());

        // Appeler la méthode doSomething() sur l'object $subject
        // qui s'attend à appeler sur le mock d'objet Observer
        // la méthod update() avec la string 'something'.
        $subject->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      Référez-vous s'il vous plait à la <ulink url="https://github.com/phpspec/prophecy#how-to-use-it">documentation</ulink>
      pour Prophecy pour plus de détails concernant la création, la configuration,
      et l'utilisation de stubs (doublures), spies (espions) et mocks (bouchons)
      en utilisation cette alternative de framework de doublure de test.
    </para>
  </section>

  <section id="test-doubles.stubbing-and-mocking-web-services">
    <title>Bouchon et simulacre pour Web Services</title>

    <para>
      <indexterm><primary>getMockFromWsdl()</primary></indexterm>

      Quand votre application interagit avec un web service, vous voulez le
      tester sans vraiment interagir avec le web service. Pour rendre facile
      la création de bouchon ou de simulacre de web services,
      <literal>getMockFromWsdl()</literal> peut être utilisée de la même façon que
      <literal>getMock()</literal> (voir plus haut). La seule différence est que
      <literal>getMockFromWsdl()</literal> retourne un bouchon ou un simulacre
      basé sur la description en WSDL d'un web service tandis que <literal>getMock()</literal>
      retourne un bouchon ou un simulacre basé sur une classe ou une interface PHP.
    </para>

    <para>
      <xref linkend="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php"/>
      montre comment <literal>getMockFromWsdl()</literal> peut être utilisé pour faire un bouchon,
      par exemple, d'un web service décrit dans <filename>GoogleSearch.wsdl</filename>.
    </para>

    <example id="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php">
      <title>Bouchonner un web service</title>
      <programlisting><![CDATA[<?php
class GoogleTest extends PHPUnit_Framework_TestCase
{
    public function testSearch()
    {
        $googleSearch = $this->getMockFromWsdl(
          'GoogleSearch.wsdl', 'GoogleSearch'
        );

        $directoryCategory = new stdClass;
        $directoryCategory->fullViewableName = '';
        $directoryCategory->specialEncoding = '';

        $element = new stdClass;
        $element->summary = '';
        $element->URL = 'http://www.phpunit.de/';
        $element->snippet = '...';
        $element->title = '<b>PHPUnit</b>';
        $element->cachedSize = '11k';
        $element->relatedInformationPresent = TRUE;
        $element->hostName = 'www.phpunit.de';
        $element->directoryCategory = $directoryCategory;
        $element->directoryTitle = '';

        $result = new stdClass;
        $result->documentFiltering = FALSE;
        $result->searchComments = '';
        $result->estimatedTotalResultsCount = 3.9000;
        $result->estimateIsExact = FALSE;
        $result->resultElements = array($element);
        $result->searchQuery = 'PHPUnit';
        $result->startIndex = 1;
        $result->endIndex = 1;
        $result->searchTips = '';
        $result->directoryCategories = array();
        $result->searchTime = 0.248822;

        $googleSearch->expects($this->any())
                     ->method('doGoogleSearch')
                     ->will($this->returnValue($result));

        /**
         * $googleSearch->doGoogleSearch() va maintenant retourner un result bouchon et
         * la méthode doGoogleSearch() du web service ne sera pas invoquée.
         */
        $this->assertEquals(
          $result,
          $googleSearch->doGoogleSearch(
            '00000000000000000000000000000000',
            'PHPUnit',
            0,
            1,
            FALSE,
            '',
            FALSE,
            '',
            '',
            ''
          )
        );
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.mocking-the-filesystem">
    <title>Simuler le système de fichiers</title>

    <para>
      <ulink url="https://github.com/mikey179/vfsStream">vfsStream</ulink>
      est un <ulink url="http://www.php.net/streams">encapsuleur de flux</ulink> pour un
      <ulink url="http://en.wikipedia.org/wiki/Virtual_file_system">système de fichiers
      virtuel</ulink> qui peut s'avérer utile dans des tests unitaires pour simuler
      le vrai système de fichiers.
    </para>

    <para>
      Pour installer vfsStream, le canal PEAR
      (<systemitem role="URL">pear.bovigo.org</systemitem>) qui est utilisé pour
      sa distribution doit être enregistré dans l'environnement local PEAR:
    </para>

    <screen><userinput>pear channel-discover pear.bovigo.org</userinput></screen>

    <para>
      Ceci ne doit être fait qu'une seule fois. Maintenant, l'installeur PEAR
      peut être utilisé pour installer vfsStream.
    </para>

    <screen><userinput>pear install bovigo/vfsStream-beta</userinput></screen>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.Example.php"/>
      montre une classe qui interagit avec le système de fichiers.
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.Example.php">
      <title>Une classe qui interagit avec le système de fichiers</title>
      <programlisting><![CDATA[<?php
class Exemple
{
    protected $id;
    protected $repertoire;

    public function __construct($id)
    {
        $this->id = $id;
    }

    public function setRepertoire($repertoire)
    {
        $this->repertoire = $repertoire . DIRECTORY_SEPARATOR . $this->id;

        if (!file_exists($this->repertoire)) {
            mkdir($this->repertoire, 0700, TRUE);
        }
    }
}?>]]></programlisting>
    </example>

    <para>
      Sans un système de fichiers virtuel tel que vfsStream, nous ne pouvons
      pas tester la méthode <literal>setDirectory()</literal> en isolation des influences
      extérieures (voir <xref
      linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest.php"/>).
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest.php">
      <title>Tester une classe qui interagoit avec le système de fichiers</title>
      <programlisting><![CDATA[<?php
require_once 'Exemple.php';

class ExempleTest extends PHPUnit_Framework_TestCase
{
    protected function setUp()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }

    public function testReprtoireEstCree()
    {
        $example = new Exemple('id');
        $this->assertFalse(file_exists(dirname(__FILE__) . '/id'));

        $example->setRepertoire(dirname(__FILE__));
        $this->assertTrue(file_exists(dirname(__FILE__) . '/id'));
    }

    protected function tearDown()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }
}
?>]]></programlisting>
    </example>

    <para>
      L'approche précédente possède plusieurs inconvénients :
    </para>

    <itemizedlist>
      <listitem><para>Comme avec les ressources externes, il peut y a voir des problèmes intermittents avec le système de fichiers. Ceci rend les tests qui interagissent avec lui peu fiables.</para></listitem>
      <listitem><para>Dans les méthodes <literal>setUp()</literal> et <literal>tearDown()</literal>, nous avons à nous assurer que le répertoire n'existe pas avant et après le test.</para></listitem>
      <listitem><para>Si l'exécution du test s'achève avant que la méthode <literal>tearDown()</literal> n'ait été appelée, le répertoire va rester dans le système de fichiers.</para></listitem>
    </itemizedlist>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php"/>
      montre comment vfsStream peut être utilisé pour simuler le système de fichiers dans un test
      pour une classe qui interagit avec le système de fichiers.
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php">
      <title>Simuler le système de fichiers dans un test pour une classe qui interagit avec le système de fichiers</title>
      <programlisting><![CDATA[<?php
require_once 'vfsStream/vfsStream.php';
require_once 'Exemple.php';

class ExempleTest extends PHPUnit_Framework_TestCase
{
    public function setUp()
    {
        vfsStreamWrapper::register();
        vfsStreamWrapper::setRoot(new vfsStreamDirectory('exempleRepertoire'));
    }

    public function testRepertoireEstCree()
    {
        $exemple = new Exemple('id');
        $this->assertFalse(vfsStreamWrapper::getRoot()->hasChild('id'));

        $exemple->setRepertoire(vfsStream::url('exempleRepertoire'));
        $this->assertTrue(vfsStreamWrapper::getRoot()->hasChild('id'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Ceci présente plusieurs avantages :
    </para>

    <itemizedlist>
      <listitem><para>Le test lui-même est plus concis.</para></listitem>
      <listitem><para>vfsStream donne au développeur du test le plein contrôle sur la façon dont le code testé voit l'environnement du système de fichiers.</para></listitem>
      <listitem><para>Puisque les opérations du système de fichiers n'opèrent plus sur le système de fichiers réel, les opérations de nettoyage dans la méthode <literal>tearDown()</literal> ne sont plus nécessaires.</para></listitem>
    </itemizedlist>
  </section>
</chapter>
